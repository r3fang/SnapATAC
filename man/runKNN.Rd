% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runKNN.R
\name{runKNN}
\alias{runKNN}
\title{K Nearest Neighbour Graph Construction}
\usage{
runKNN(obj, pca.dims, weight.by.sd, k, nn.eps, save.knn, filename, snn,
  snn.prune)
}
\arguments{
\item{obj}{A snap object}

\item{pca.dims}{A vector of the dimensions to use in construction of the KNN graph.}

\item{weight.by.sd}{Weight the cell embeddings by the sd of each PC}

\item{k}{K for the k-nearest neighbor algorithm.}

\item{nn.eps}{Error bound when performing nearest neighbor seach using RANN.
default of 0.0 implies exact nearest neighbor search}

\item{save.knn}{Default is to store the KNN in object@kmat. Setting
to FALSE can be used together with a provided filename to only write the KNN
out as an edge file to disk. This is compatible with runCluster.}

\item{filename}{Write KNN directly to file named here as an edge list
compatible with runCluster.}

\item{snn}{Setting to TRUE can convert KNN graph into a SNN graph.}

\item{snn.prune}{Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap. Any edges with values less than or 
equal to this will be set to 0 and removed from the SNN graph. Essentially 
sets the strigency of pruning (0 --- no pruning, 1 --- prune everything).}
}
\value{
Returns the object with object@kmat filled
}
\description{
Constructs a K Nearest Neighbor (SNN) Graph from a snap object. 
The k-nearest neighbors of each cell were identified and used to create
a KNN graph.
}
\details{
Using the selected significant principal components (PCs), we next calculated pairwise 
Euclidean distance between every two cells, using this distance, we created a k-nearest 
neighbor graph in which every cell is represented as a node and edges are drawn between 
cells within k nearest neighbors. Edge weight between any two cells can be refined by shared 
overlap in their local neighborhoods using Jaccard similarity (snn).
}
