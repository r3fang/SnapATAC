<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Fang_2019</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h2 id="toc_0">Analysis of Mouse Secondary Motor Cortex (MOs)</h2>

<p><strong><em><em>Please note that the data displayed here is only a subset of MOs reported in Fang 2019 paper.</em></em></strong><br>
In Fang 2019, mouse secondary motor cortex is dissected into three slices namely anterior, middle and posterior, each having two biological replicates. In this tutorial, we will analyze one dataset <code>CEMBA180306_2B</code> which is the first replicate for middle (2nd) slice.</p>

<p><img src="./MOs_slices.png" width="700" height="300" /></p>

<p><strong>Step 0. Download the snap file</strong>.<br>
snap (Single Nucleus Accessibility Profile) file is a hierarchically structured hdf5 file that is specially designed for storing single nucleus ATAC-seq datasets. A snap file (version 4) contains the following sessions: header (HD), cell-by-bin accessibility matrix (AM), cell-by-peak matrix (PM), cell-by-gene matrix (GM), barcode (BD) and fragment (FM).</p>

<ul>
<li>HD session contains snap-file version, created date, alignment and reference genome information.</li>
<li>BD session contains all unique barcodes and corresponding meta data.</li>
<li>AM session contains cell-by-bin matrices of different resolutions (or bin sizes).</li>
<li>PM session contains cell-by-peak count matrix. </li>
<li>GM session contains cell-by-gene count matrix.</li>
<li>FM session contains all usable fragments for each cell. Fragments are indexed for fast search.</li>
</ul>

<p>Detailed information about snap file can be found <a href="https://github.com/r3fang/SnapTools/blob/master/docs/snap_format.docx">here</a>. See how to generate CEMBA180306_2B.snap <a href="https://github.com/r3fang/SnapATAC/wiki/FAQs">here</a>.</p>

<div><pre><code class="language-R">$ R
&gt; system(&quot;wget http://renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/snap/CEMBA180306_2B.snap&quot;)</code></pre></div>

<p><strong>Step 1. Barcode selection (SnapATAC)</strong><br>
Using snap file, we next identify the high-quality barcode based on the following metrices: 1) <code>fragment.num</code> - Total Sequencing Fragments; 2) <code>umap.ratio</code> - uniquely mapped ratio; 3) <code>dup.ratio</code> - duplate ratio; 4) <code>pair.ratio</code> - properly paired ratio; 5) <code>mito.ratio</code> - mitochondrial ratio. </p>

<p>Note that we no longer use reads in peak ratio as a metric for cell selection mainly for two reasons: First, we found the reads-in-peak ration is highly cell type specific. For instance, according to published single cell ATAC-seq, human fibroblast (BJ) cells have significantly higher reads in peak ratio (40-60%) versus 20-40% for GM12878 cells. Similarly, we found Glia cells overall have very different reads in peak ratio distribution compared to neuronal cells. We suspect this may reflect the nucleus size or global chromatin accessibility. Second, accessibility peaks identified from aggregate signal are usually incomplete and are biased to the dominant populations. When studying complex tissue such as mammalian brain, we found it is up to 50% of the peaks present in the rare populations are not identified from the bulk analysis. Therefore, we abandon the use of reads in peak ratio for cell selection. <strong>NOTE: plotBarcode only works with snap file generated by snaptools.</strong></p>

<div><pre><code class="language-R">&gt; library(SnapATAC);
&gt; x.sp = createSnap(
                    file=&quot;CEMBA180306_2B.snap&quot;,
                    metaData=TRUE,
                    des=&quot;2nd slice of MOs&quot;
                   );
&gt; plotBarcode(x.sp, 
              pdf.file.name=NULL, 
              pdf.width=7, 
              pdf.height=7, 
              col=&quot;grey&quot;,
              border=&quot;grey&quot;,
              breaks=50
              );</code></pre></div>

<p><img src="./Barcode_QC.png" width="500" height="500" /></p>

<div><pre><code class="language-R"># filter cells based on the following cutoffs
&gt; x.sp = filterCells(x.sp, 
                   subset.names=c(&quot;fragment.num&quot;, &quot;UMI&quot;),
                   low.thresholds=c(1000,500),
                   high.thresholds=c(Inf, Inf)
                  );
&gt; x.sp 

2nd slice of MOs
===================
number of barcodes: 11342
number of bins: 0
number of peaks: 0
number of genes: 0

&gt; summarySnap(x.sp)
Total  number of barcodes: 11342
Median number of sequencing fragments: 5334
Median number of uniquely mapped fragments: 3769.5
Median number of mappability ratio: 0.94
Median number of properly paired ratio: 1
Median number of duplicate ratio: 0.27
Median number of chrM ratio: 0.01
Median number of unique molecules (UMI): 3769.5</code></pre></div>

<p><strong>Step 2. Bin size selection (SnapATAC)</strong><br>
Using remaining cells, we next deteremine the optimal bin size based on the correlation between replicates using (<code>calBmatCor</code>). If there are no biological replicates, the cells are evenly split into pseudo-replicates. We recommend chosing the smallest bin size that yields correlation greater than 0.95. In this example, the <code>CEMBA180306_2B.snap</code> file only contains 5kb cell-by-bin matrix and its correlation is 0.97. </p>

<div><pre><code class="language-R"># show what bin sizes exist in CEMBA180306_2B.snap file
&gt; showBinSizes(&quot;CEMBA180306_2B.snap&quot;);
&gt; x.sp = addBmatToSnap(x.sp, &quot;CEMBA180306_2B.snap&quot;, bin.size=5000);
&gt; calBmatCor(x.sp);
[1] 0.9714672</code></pre></div>

<p><strong>Step 3. Matrix binarization (SnapATAC)</strong><br>
We next convert the cell-by-bin count matrix to a binary matrix. We found some items in the matrix have abnormally high coverage perhaps due to the alignment error. Therefore, we first remove top 0.1% items in the count matrix and then convert the rest of the values into binary.</p>

<div><pre><code class="language-R">&gt; x.sp = makeBinary(x.sp, mat=&quot;bmat&quot;);</code></pre></div>

<p><strong>Step 4. Bin filtration (SnapATAC)</strong><br>
We next filter out any bins overlapping with the <a href="http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/">ENCODE blacklist</a> and bins belonging to chrM or random chromsomes to prevent from any potential artifacts. </p>

<div><pre><code class="language-R">&gt; library(GenomicRanges);
&gt; system(&quot;wget http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/mm10-mouse/mm10.blacklist.bed.gz&quot;)
&gt; black_list = read.table(&quot;mm10.blacklist.bed.gz&quot;);
&gt; black_list.gr = GRanges(
                          black_list[,1], 
                          IRanges(black_list[,2], black_list[,3])
                         );
&gt; idy1 = queryHits(findOverlaps(x.sp@feature, black_list.gr));
&gt; idy2 = grep(&quot;chrM|random&quot;, x.sp@feature);
&gt; idy = unique(c(idy1, idy2));
&gt; x.sp = x.sp[,-idy, mat=&quot;bmat&quot;];
&gt; x.sp
2nd slice of MOs
===================
number of barcodes: 11342
number of bins: 545011
number of peaks: 0
number of genes: 0</code></pre></div>

<p><img src="./Bin_coverage.png" width="300" height="300" /></p>

<p>Bins of exceedingly high coverage are removed which likely represent the genomic regions that are invariable between cells such as housekeeping gene promoters. We also notice that filtering bins of very low coverage perhaps due to random noise can also improve the robustness of the downstream clustering analysis. In detail, we first calculate the coverage of each bin using the binary matrix and then normalize the coverage by <code>log10(count + 1)</code>. The log-scaled coverage obey approximately a gaussian distribution which is then converted into zscore. In the following example, bins with zscore beyond Â±2 were filtered. </p>

<div><pre><code class="language-R">&gt; plotBinCoverage(
    x.sp,
    pdf.file.name=NULL,
    col=&quot;grey&quot;,
    border=&quot;grey&quot;,
    breaks=10,
    xlim=c(-6,6)
    );
&gt; x.sp = filterBins(
    x.sp,
    low.threshold=-2,
    high.threshold=2,
    mat=&quot;bmat&quot;
    );
&gt; x.sp
2nd slice of MOs
===================
number of barcodes: 11342
number of bins: 476903
number of peaks: 0
number of genes: 0
</code></pre></div>

<p><strong>Step 5. Jaccard matrix (SnapATAC)</strong><br>
We next convert the filtered genome-wide cell-by-bin matrix into a cell-by-cell similarity matrix by estimating the jaccard index between two cells in the basis of profile overlaps. Instead of calculating a full N-by-N jaccard matrix, we calculate a partial jaccard index matrix by randomly choosing <code>max.var</code> cells. By doing so, we demonstrate that it does not sacrifice the performance but significantly improves the scalability of the method.</p>

<div><pre><code class="language-R">&gt; x.sp = runJaccard(
    obj = x.sp,
    mat = &quot;bmat&quot;,
    max.var=2000,
    ncell.chunk=10000,
    seed.use=10
    );</code></pre></div>

<p><strong>Step 6. Normalization (SnapATAC)</strong><br>
Due to the high dropout rate, we found that the jaccard index is highly affected by the differing read depth between cells. To eliminate such confounding factor, we have developed two methods for normalizing jaccard index normOVE and normOVN.</p>

<div><pre><code class="language-R">&gt; x.sp = runNormJaccard(
    obj = x.sp,
    ncell.chunk=1000,
    method=&quot;normOVE&quot;,
    row.center=TRUE,
    row.scale=TRUE,
    low.threshold=-5,
    high.threshold=5,
    num.cores=5,
    seed.use=10
    );</code></pre></div>

<p><strong>Step 7. Linear Dimentionality Reduction (SnapATAC)</strong><br>
Like other single-cell analysis, snATAC-seq contains extensive technical noise due to the high drop-out rate. To overcome this challenge, PCA or SVD is often applied to combine information across a correlated feature set hereby creating a mega-feature and exclude the variance potential resulting from technical noise. Here, we performed PCA against the normalized matrix. We used IRLBA algorithm, a fast and memory-efficient algorithm, to compute a partial PCA. IRLBA is implemented in  <code>irlba</code> R package.</p>

<div><pre><code class="language-R">&gt; x.sp = runDimReduct(
    x.sp,
    pc.num=50,
    input.mat=&quot;jmat&quot;,
    method=&quot;svd&quot;,
    center=TRUE,
    scale=FALSE,
    seed.use=10
    );</code></pre></div>

<p><strong>Step 8. Determine statistically significant principal components (SnapATAC)</strong><br>
We next Determine how many PCs to include for downstream analysis. We use an ad hoc method for determining which PCs to use is to look at a plot of the standard deviations of the principle components and draw your cutoff where there is a clear elbow in the graph. The other ad hoc way to determine PCs is to plot out every two PCs and select until PCs that have no obvious structure. </p>

<div><pre><code class="language-R">&gt; plotDimReductElbow(
    obj=x.sp, 
    point.size=1.5,
    point.shape=19,
    point.color=&quot;red&quot;,
    point.alpha=1,
    pdf.file.name=NULL,
    pdf.height=7,
    pdf.width=7,
    labs.title=&quot;PCA Elbow plot&quot;,
    labs.subtitle=NULL,
    );
&gt; plotDimReductPW(
    obj=x.sp, 
    pca.dims=1:50,
    point.size=0.3,
    point.color=&quot;grey&quot;,
    point.shape=19,
    point.alpha=0.6,
    down.sample=5000,
    pdf.file.name=NULL, 
    pdf.height=7, 
    pdf.width=7,
    );</code></pre></div>

<p><img src="./PCA_elbow_plot.png" width="350" height="350" /> 
<img src="./PCA_scatter_plot.png" width="350" height="350" /> </p>

<p><strong>Step 9. KNN Graph Construction (SnapATAC)</strong><br>
Using selected significant components, we next construct a K Nearest Neighbor (KNN) Graph. Using euclidean distance, the k-nearest neighbors of each cell are identified accoriding and used to create a KNN graph. KNN graph can be further refined to SNN (Shared Nearest Neighbor) graph by adding edge weight between cells as shared overlap in their local neighborhoods using Jaccard similarity. <strong>This function is inspired and modified from Seurat package.</strong> (ignore <code>save.knn</code> and <code>filename</code> for a dataset with less than 100,000 cells).</p>

<div><pre><code class="language-R">&gt; x.sp = runKNN(
    obj=x.sp,
    pca.dims=1:30,
    weight.by.sd=FALSE,
    k=15,
    nn.eps=0.0,
    snn=TRUE,
    prune.snn=1/15,
    save.knn=FALSE,
    filename=NULL
    );</code></pre></div>

<p><strong>Step 10. Clustering (SnapATAC)</strong><br>
Using KNN graph, we next apply community finding algorithm Louvain to identify the clusters in the resulting graph which represent groups of cells sharing similar ATAC-seq profiles, potentially originating from the same cell type.</p>

<div><pre><code class="language-R">&gt; x.sp = runCluster(
    obj=x.sp,
    louvain.lib=&quot;R-igraph&quot;,
    path.to.snaptools=NULL,
    load.knn.from.file=FALSE,
    edge.file=NULL,
    seed.use=10
    );</code></pre></div>

<p>Alterantively, we can run louvain cluster using <code>snaptools</code> with different <code>resolution</code>. Note this runs a bit longer. Here we use result from <code>R-igraph</code> for downstream analysis.</p>

<div><pre><code class="language-R">&gt; system(&quot;which snaptools&quot;);
&gt; x2.sp = runCluster(
    obj=x.sp,
    louvain.lib=&quot;python-louvain&quot;,
    resolution=0.5,
    path.to.snaptools=&quot;/home/r3fang/anaconda2/bin/snaptools&quot;,
    load.knn.from.file=FALSE,
    edge.file=NULL,
    seed.use=10
    );
&gt; rm(x2.sp);</code></pre></div>

<p><strong>Step 11. Non-linear dimentionality reduction (SnapATAC)</strong><br>
SnapATAC allows using tSNE, UMAP and FIt-sne to visualize and explore these datasets. In the following example, data is visulized by tsne implemented by R package (Rtsne). To run <code>umap</code>, you need to first install umap package. To run <code>fast_tsne</code>, you need to first install <a href="https://github.com/KlugerLab/FIt-SNE/blob/master/fast_tsne.R">fast_tsne package</a>.</p>

<div><pre><code class="language-R">&gt; x.sp = runViz(
    obj=x.sp, 
    dims=2,
    pca.dims=1:30, 
    weight.by.sd=FALSE,
    method=&quot;Rtsne&quot;,
    fast_tsne_path=NULL,
    Y.init=NULL,
    seed.use=10,
    num.cores=5
    );
&gt; x.sp = runViz(
    obj=x.sp, 
    dims=2,
    pca.dims=1:30, 
    weight.by.sd=FALSE,
    method=&quot;umap&quot;,
    fast_tsne_path=NULL,
    Y.init=NULL,
    seed.use=10,
    num.cores=5
    );
&gt; system(&quot;which fast_tsne&quot;);
/projects/ps-renlab/r3fang/public_html/github/FIt-SNE/bin/fast_tsne
&gt; x.sp = runViz(
    obj=x.sp, 
    dims=2,
    pca.dims=1:30, 
    weight.by.sd=FALSE,
    method=&quot;fast_tsne&quot;,
    fast_tsne_path=&quot;/projects/ps-renlab/r3fang/public_html/github/FIt-SNE/bin/fast_tsne&quot;,
    Y.init=NULL,
    seed.use=10,
    num.cores=5
    );</code></pre></div>

<p><strong>Step 12. Visulization (SnapATAC)</strong><br>
SnapATAC allows using tSNE, UMAP and FIt-sne to visualize and explore these datasets. In the following example, data is visulized by tsne implemented by R package (Rtsne).</p>

<div><pre><code class="language-R">&gt; plotViz(
    obj=x.sp, 
    method=&quot;tsne&quot;, 
    point.size=0.5, 
    point.shape=19, 
    point.alpha=0.8, 
    text.add=TRUE,
    text.size=1.5,
    text.color=&quot;black&quot;,
    text.halo.add=TRUE,
    text.halo.color=&quot;white&quot;,
    text.halo.width=0.2,
    down.sample=10000,
    pdf.file.name=NULL,
    pdf.width=7, 
    pdf.height=7
    );
&gt; plotViz(
    obj=x.sp, 
    method=&quot;umap&quot;, 
    point.size=0.5, 
    point.shape=19, 
    point.alpha=0.8, 
    text.add=TRUE,
    text.size=1.5,
    text.color=&quot;black&quot;,
    text.halo.add=TRUE,
    text.halo.color=&quot;white&quot;,
    text.halo.width=0.2,
    down.sample=10000,
    pdf.file.name=NULL,
    pdf.width=7, 
    pdf.height=7
    );</code></pre></div>

<p><img src="./Viz_tsne.png" width="350" height="330" />  <img src="./Viz_umap.png" width="350" height="330" /> </p>

<p><strong>Step 13. Gene-body based annotation for expected cell types (SnapATAC)</strong><br>
To help annotate identified cell clusters, SnapATAC next loads the cell-by-gene matrix which estimates the gene body accessibility level.</p>

<div><pre><code class="language-R">&gt; x.sp = addGmatToSnap(x.sp, &quot;CEMBA180306_2B.snap&quot;);
&gt; x.sp = scaleCountMatrix(
    x.sp, 
    cov=x.sp@metaData$UQ,
    mat=&quot;gmat&quot;,
    method = &quot;RPM&quot;
    );
&gt; marker.genes = c(
   &quot;Snap25&quot;, &quot;Gad2&quot;, &quot;Apoe&quot;,
    &quot;C1qb&quot;, &quot;Pvalb&quot;, &quot;Vip&quot;, 
    &quot;Sst&quot;, &quot;Lamp5&quot;, &quot;Slc17a7&quot;, 
    &quot;Mog&quot;, &quot;Pdgfra&quot;, &quot;Cspg4&quot;,
    &quot;Cx3cr1&quot;,&quot;F3&quot;,&quot;Aqp4&quot;, 
    &quot;Rorb&quot;
    );
&gt; plotGene(
    obj=x.sp, 
    gene.names=marker.genes,
    viz.method=&quot;tsne&quot;,
    point.size=0.3,
    point.color=&quot;red&quot;,
    point.shape=19,
    background.point=TRUE,
    background.point.color=&quot;grey&quot;,
    background.point.alpha=0.3,
    background.point.size=0.1,
    background.point.shape=19,
    low.value=0.0,
    high.value=0.95,
    down.sample=5000,
    seed.use=10,
    plot.nrow=4,
    plot.ncol=4,
    pdf.file.name=NULL, 
    pdf.height=7, 
    pdf.width=7
    );</code></pre></div>

<p><img src="./gene_plot.png" width="700" height="700" /></p>

<p><strong>Step 14. Heretical clustering of the clusters (SnapATAC)</strong>        </p>

<div><pre><code class="language-R"># calculate the ensemble signals for each cluster
&gt; ensemble.ls = lapply(split(seq(length(x.sp@cluster)), x.sp@cluster), function(x){
    Matrix::colMeans(x.sp@bmat[x,])
    })
# cluster using 1-cor as distance  
&gt; hc = hclust(as.dist(1 - cor(t(do.call(rbind, ensemble.ls)))), method=&quot;ward.D2&quot;);
&gt; plot(hc, hang=-1, xlab=&quot;&quot;);</code></pre></div>

<p><img src="./cluster_tree.png" width="800" height="400" /></p>

<p><strong>Step 15. Gene-body based annotation for excitatory neurons</strong><br>
We next extracted the clusters belonging to excitatory neurons based on the gene accessibility level for Slc17a7 and plot layer-specific marker genes enrichment.</p>

<div><pre><code class="language-R">&gt; idx = which(x.sp@cluster %in% c(11, 1, 7, 13, 19, 10, 9, 20));
&gt; length(idx) # 6035 53% of total population
&gt; marker.genes = c(
     &quot;Cux2&quot;, &quot;Rorb&quot;, &quot;Deptor&quot;, 
     &quot;Vat1l&quot;, &quot;Sulf1&quot;, &quot;Tle4&quot;, 
     &quot;Foxp2&quot;, &quot;Tshz2&quot;, &quot;Grik3&quot;
    );
&gt; plotGene(
    obj=x.sp[idx,], 
    gene.names=marker.genes,
    viz.method=&quot;tsne&quot;,
    point.size=0.2,
    point.color=&quot;red&quot;,
    point.shape=19,
    background.point=TRUE,
    background.point.color=&quot;grey&quot;,
    background.point.alpha=0.3,
    background.point.size=0.1,
    background.point.shape=19,
    low.value=0.0,
    high.value=1.0,
    down.sample=5000,
    seed.use=10,
    plot.nrow=3,
    plot.ncol=3,
    pdf.file.name=NULL, 
    pdf.height=7, 
    pdf.width=7
    );</code></pre></div>

<p><img src="./gene_plot_exc.png" width="700" height="700" /></p>

<p><strong>Step 16. Change the cluster label to cell type</strong>  </p>

<div><pre><code class="language-R">&gt; library(plyr);
&gt; current.cluster.ids &lt;- 1:21;
&gt; new.cluster.ids &lt;- c(&quot;L5.IT&quot;, &quot;Lamp5&quot;, &quot;Other.a&quot;, 
                            &quot;Sst&quot;,   &quot;Vip&quot;,   &quot;Other.b&quot;,
                            &quot;L6.IT&quot;, &quot;Asc&quot;,   &quot;L6b&quot;,
                            &quot;L5.PT&quot;,   &quot;NP&quot;,    &quot;Ogc&quot;,
                            &quot;L4&quot;,    &quot;Mgc&quot;,   &quot;Other.c&quot;,
                            &quot;Asc&quot;,  &quot;Pvalb&quot;,  &quot;Ogc&quot;,
                            &quot;L23.IT&quot;, &quot;L6.CT&quot;, &quot;Opc&quot;
                            );
&gt; x.sp@cluster &lt;- plyr::mapvalues(x = x.sp@cluster, from = current.cluster.ids, to = new.cluster.ids);
&gt; plotViz(
    obj=x.sp, 
    method=&quot;tsne&quot;, 
    point.size=0.5, 
    point.shape=19, 
    point.alpha=0.8, 
    text.add=TRUE,
    text.size=1.3,
    text.color=&quot;black&quot;,
    text.halo.add=TRUE,
    text.halo.color=&quot;white&quot;,
    text.halo.width=0.2,
    down.sample=10000,
    pdf.file.name=NULL,
    pdf.width=7, 
    pdf.height=7
    );  </code></pre></div>

<p><img src="./Viz_tsne_cell_type.png" width="400" height="370" /></p>

<p><strong>Step 17. Identify cis-elements for each cluster seperately</strong>      </p>

<div><pre><code class="language-R">&gt; system(&quot;which snaptools&quot;)
/home/r3fang/anaconda2/bin/snaptools
&gt; system(&quot;which macs2&quot;)
/home/r3fang/anaconda2/bin/macs2
&gt; peaks_sst.df = runMACS(
    obj=x.sp[which(x.sp@cluster==&quot;Sst&quot;),], 
    file=&quot;CEMBA180306_2B.snap&quot;, 
    output.prefix=&quot;CEMBA180306_2B.Sst&quot;,
    path.to.snaptools=&quot;/home/r3fang/anaconda2/bin/snaptools&quot;,
    path.to.macs=&quot;/home/r3fang/anaconda2/bin/macs2&quot;,
    gsize=&quot;mm&quot;, 
    buffer.size=500, 
    macs.options=&quot;--nomodel --shift 37 --ext 73 --qval 1e-2 -B --SPMR --call-summits&quot;,
    tmp.folder=NULL
    );</code></pre></div>

<p>Call peaks for clusters with cells more than 300 cells.</p>

<div><pre><code class="language-R">&gt; peak.gr = runMACSForAll(
    obj=x.sp,
    file=&quot;CEMBA180306_2B.snap&quot;,
    output.prefix=&quot;CEMBA180306_2B&quot;,
    path.to.snaptools=&quot;/home/r3fang/anaconda2/bin/snaptools&quot;,
    path.to.macs=&quot;/home/r3fang/anaconda2/bin/macs2&quot;,
    num.cores=10,
    min.cells=300,
    gsize=&quot;mm&quot;, 
    buffer.size=500, 
    macs.options=&quot;--nomodel --shift 37 --ext 73 --qval 1e-2 -B --SPMR --call-summits&quot;,
    tmp.folder=NULL
    ); 
&gt; peaks.gr
GRanges object with 190276 ranges and 0 metadata columns:
           seqnames               ranges strand
              &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt;
       [1]     chr1   [3095032, 3095530]      *
       [2]     chr1   [3113755, 3113828]      *
       [3]     chr1   [3119616, 3120678]      *
       [4]     chr1   [3121467, 3121578]      *
       [5]     chr1   [3167265, 3167370]      *
       ...      ...                  ...    ...
  [190272]     chrY [90803444, 90803664]      *
  [190273]     chrY [90807594, 90807850]      *
  [190274]     chrY [90808789, 90808945]      *
  [190275]     chrY [90809504, 90809630]      *
  [190276]     chrY [90829048, 90829121]      *
  -------
  seqinfo: 22 sequences from an unspecified genome; no seqlengths</code></pre></div>

<p><strong>Step 18. Create a cell-by-peak matrix</strong><br>
Using merged peaks as a reference, we next create a cell-by-peak matrix using the original snap file.</p>

<div><pre><code class="language-none">&gt; runSnapAddPmat(
    file=&quot;CEMBA180306_2B.snap&quot;, 
    peak=peaks.gr, 
    path.to.snaptools=&quot;/home/r3fang/anaconda2/bin/snaptools&quot;, 
    buffer.size=500
    );</code></pre></div>

<p>Because the <code>snap</code> file you have downloaded already has cell-by-peak matrix, we can just upload the cell-by-peak matrix into the existing snap object without running the previous step.</p>

<div><pre><code class="language-R">&gt; x.sp = addPmatToSnap(obj=x.sp, file=&quot;CEMBA180306_2B.snap&quot;);</code></pre></div>

<p><strong>Step 19. Identify Differentially Accessible Regions (DARs)</strong><br>
SnapATAC can help find differentially accessible regions (DARs) that define clusters via differential analysis. By default, it identifes positive peaks of a single cluster (specified in <code>cluster.pos</code>), compared to a group of negative control cells.</p>

<div><pre><code class="language-R">&gt; idy_sst = findDAR(
    obj=x.sp,
    mat=&quot;pmat&quot;,
    cluster.pos=&quot;Sst&quot;,
    cluster.neg=NULL,
    bcv=0.1,
    fdr=5e-2,
    pvalue=1e-2,
    test.method=&quot;exactTest&quot;,
    seed.use=10
    );
&gt; idy_mgc = findDAR(
    obj=x.sp,
    mat=&quot;pmat&quot;,
    cluster.pos=&quot;Mgc&quot;,
    cluster.neg=NULL,
    bcv=0.1,
    fdr=1e-2,
    pvalue=1e-2,
    test.method=&quot;exactTest&quot;,
    seed.use=10
    );
&gt; y_sst = Matrix::rowSums(x.sp@pmat[, idy_sst]) / x.sp@metaData$UQ * 1000000;
&gt; y_mgc = Matrix::rowSums(x.sp@pmat[, idy_mgc]) / x.sp@metaData$UQ * 1000000;
&gt; y_sst = (y_sst - mean(y_sst)) / sd(y_sst);
&gt; y_mgc = (y_mgc - mean(y_mgc)) / sd(y_mgc);
&gt; boxPlotFeature(
    obj = x.sp,
    feature = y_sst,
    outline = FALSE,
    ylab = &quot;zscore of RPM&quot;,
    main = &quot;Sst DARs Enrichment&quot;,
    add.point = TRUE,
    point.size = 0.2,
    point.shape = 19,
    point.alpha = 0.5,
    pdf.file.name=NULL,
    pdf.height=7,
    pdf.width=7
    );
&gt; boxPlotFeature(
    obj = x.sp,
    feature = y_mgc,
    outline = FALSE,
    ylab = &quot;zscore of RPM&quot;,
    main = &quot;Sst DARs Enrichment&quot;,
    add.point = TRUE,
    point.size = 0.2,
    point.shape = 19,
    point.alpha = 0.5,
    pdf.file.name=NULL,
    pdf.height=7,
    pdf.width=7
    );</code></pre></div>

<p><img src="./boxplot_Sst.png" width="350" height="300" />
<img src="./boxplot_Mgc.png" width="360" height="325" /></p>

<p><strong>Step 20. Motif analysis identifies master regulators</strong><br>
SnapATAC can help reveal master regulators that are enriched in the differentially accessible regions (DARs). </p>

<div><pre><code class="language-R">&gt; system(&quot;which findMotifsGenome.pl&quot;);
/projects/ps-renlab/r3fang/public_html/softwares/homer/bin/findMotifsGenome.pl
&gt; motifs = runHomer(
    x.sp[,idy_sst,&quot;pmat&quot;], 
    mat = &quot;pmat&quot;,
    path.to.homer = &quot;/projects/ps-renlab/r3fang/public_html/softwares/homer/bin/findMotifsGenome.pl&quot;,
    result.dir = &quot;./homer/Sst&quot;,
    num.cores=5,
    genome = &#39;mm10&#39;,
    motif.length = 10,
    scan.size = 300,
    optimize.count = 2,
    background = &#39;automatic&#39;,
    local.background = FALSE,
    only.known = FALSE,
    only.denovo = FALSE,
    fdr.num = 5,
    cache = 100,
    overwrite = TRUE,
    keep.minimal = FALSE
    );
&gt; head(motifs)
                                                     Motif.Name   Log.P.value
1 Tcf21(bHLH)/ArterySmoothMuscle-Tcf21-ChIP-Seq(GSE61369)/Homer        -940.4
2            Tcf12(bHLH)/GM12878-Tcf12-ChIP-Seq(GSE32465)/Homer        -801.1
3        Ascl1(bHLH)/NeuralTubes-Ascl1-ChIP-Seq(GSE55840)/Homer        -785.8
4                  Ap4(bHLH)/AML-Tfap4-ChIP-Seq(GSE45738)/Homer        -753.7
5              Ptf1a(bHLH)/Panc1-Ptf1a-ChIP-Seq(GSE47459)/Homer        -718.6
6               E2A(bHLH)/proBcell-E2A-ChIP-Seq(GSE21978)/Homer        -697.5
</code></pre></div>

<p>Find motifs enriched in Mgc DARs.</p>

<div><pre><code class="language-R">&gt; motifs = runHomer(
    x.sp[,idy_mgc,&quot;pmat&quot;], 
    mat = &quot;pmat&quot;,
    path.to.homer = &quot;/projects/ps-renlab/r3fang/public_html/softwares/homer/bin/findMotifsGenome.pl&quot;,
    result.dir = &quot;./homer/Mgc&quot;,
    num.cores=5,
    genome = &#39;mm10&#39;,
    motif.length = 10,
    scan.size = 300,
    optimize.count = 2,
    background = &#39;automatic&#39;,
    local.background = FALSE,
    only.known = FALSE,
    only.denovo = FALSE,
    fdr.num = 5,
    cache = 100,
    overwrite = TRUE,
    keep.minimal = FALSE
    );
&gt; head(motifs)
                                         Motif.Name   Log.P.value
1   PU.1(ETS)/ThioMac-PU.1-ChIP-Seq(GSE21512)/Homer         -3880       
2      Elf4(ETS)/BMDM-Elf4-ChIP-Seq(GSE88699)/Homer         -3589      
3    SpiB(ETS)/OCILY3-SPIB-ChIP-Seq(GSE56857)/Homer         -3218      
4      ELF5(ETS)/T47D-ELF5-ChIP-Seq(GSE30407)/Homer         -3208       
5    ETS1(ETS)/Jurkat-ETS1-ChIP-Seq(GSE17954)/Homer         -2824      
6 Etv2(ETS)/ES-ER71-ChIP-Seq(GSE59402)/Homer(0.967)         -2628       </code></pre></div>

<p><strong>Step 21. Subclustering of Sst reveals rare population</strong><br>
GABAergic neurons are composed of highly diverse neurons. Previous single cell RNA-seq analysis has revealed extensive amount of GABAergic subtypes. Here we perform sub-cluster of Sst to further identify its subtype. In this example, SnapATAC identifies very rare population Sst Chodl (15 cells) which counts for less than 0.1% of total population. </p>

<div><pre><code class="language-R">&gt; x.sst.sp = x.sp[which(x.sp@cluster == &quot;Sst&quot;),];
&gt; x.sst.sp
2nd slice of MOs
===================
number of barcodes: 341
number of bins: 476589
number of peaks: 316257
number of genes: 53278

&gt; x.sst.sp = runJaccard(
    obj = x.sst.sp,
    mat = &quot;bmat&quot;,
    max.var=2000,
    ncell.chunk=10000,
    num.cores=1,
    seed.use=10
    );
&gt; x.sst.sp = runNormJaccard(
    obj = x.sst.sp,
    ncell.chunk=1000,
    method=&quot;normOVE&quot;,
    row.center=TRUE,
    row.scale=TRUE,
    low.threshold=-5,
    high.threshold=5,
    num.cores=5,
    seed.use=10
    );
&gt; x.sst.sp = runDimReduct(
    x.sst.sp,
    pc.num=50,
    input.mat=&quot;jmat&quot;,
    method=&quot;svd&quot;,
    center=TRUE,
    scale=FALSE,
    seed.use=10
    );
&gt; plotDimReductPW(
    obj=x.sst.sp, 
    pca.dims=1:40,
    point.size=1,
    point.color=&quot;grey&quot;,
    point.shape=19,
    point.alpha=0.6,
    down.sample=1000,
    pdf.file.name=NULL, 
    pdf.height=7, 
    pdf.width=7,
    );
&gt; x.sst.sp = runKNN(
    obj= x.sst.sp,
    pca.dims=1:10,
    weight.by.sd=FALSE,
    k=15,
    nn.eps=0.0,
    snn=TRUE,
    prune.snn=1/15,
    save.knn=FALSE,
    filename=NULL
    );
&gt; x.sst.sp = runCluster(
    obj=x.sst.sp,
    louvain.lib=&quot;R-igraph&quot;,
    path.to.snaptools=NULL,
    load.knn.from.file=FALSE,
    edge.file=NULL,
    seed.use=10
    );
&gt; x.sst.sp = runViz(
    obj=x.sst.sp, 
    dims=2,
    pca.dims=1:10, 
    weight.by.sd=FALSE,
    method=&quot;umap&quot;,
    fast_tsne_path=NULL,
    Y.init=NULL,
    seed.use=10,
    num.cores=5
    );
&gt; plotViz(
    obj=x.sst.sp, 
    method=&quot;umap&quot;, 
    point.size=2, 
    point.shape=19, 
    point.alpha=1, 
    text.add=TRUE,
    text.size=1.5,
    text.color=&quot;black&quot;,
    text.halo.add=TRUE,
    text.halo.color=&quot;white&quot;,
    text.halo.width=0.2,
    down.sample=10000,
    pdf.file.name=NULL,
    pdf.width=7, 
    pdf.height=7
    );
&gt; plotGene(
    obj=x.sst.sp, 
    gene.names=c(&quot;Chodl&quot;),
    viz.method=&quot;umap&quot;,
    point.size=1,
    point.color=&quot;red&quot;,
    point.shape=19,
    background.point=TRUE,
    background.point.color=&quot;grey&quot;,
    background.point.alpha=0.5,
    background.point.size=1,
    background.point.shape=19,
    low.value=0.0,
    high.value=1.0,
    down.sample=5000,
    seed.use=10,
    plot.nrow=1,
    plot.ncol=1,
    pdf.file.name=NULL, 
    pdf.height=7, 
    pdf.width=7
    );</code></pre></div>

<p><img src="./umap_sst_chodl.png" width="350" height="350" />
<img src="./umap_sst.png" width="350" height="350" /></p>

<p><strong>Elapsed time for key steps</strong><br>
These tests were performed on a machine running CentOS release 6.6 (Final) with an Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz and 63GB of RAM.</p>

<table>
<thead>
<tr>
<th>Function</th>
<th style="text-align: left">Time (sec)</th>
</tr>
</thead>

<tbody>
<tr>
<td>createSnap</td>
<td style="text-align: left">0.149 sec</td>
</tr>
<tr>
<td>filterCells</td>
<td style="text-align: left">0.059 sec</td>
</tr>
<tr>
<td>addBmatToSnap</td>
<td style="text-align: left">41.571 sec</td>
</tr>
<tr>
<td>makeBinary</td>
<td style="text-align: left">3.621 sec</td>
</tr>
<tr>
<td>filterBins</td>
<td style="text-align: left">1.162 sec</td>
</tr>
<tr>
<td>runJaccard</td>
<td style="text-align: left">30.822 sec</td>
</tr>
<tr>
<td>runNormJaccard</td>
<td style="text-align: left">23.905 sec</td>
</tr>
<tr>
<td>runDimReduct</td>
<td style="text-align: left">18.639 sec</td>
</tr>
<tr>
<td>runKNN (snn)</td>
<td style="text-align: left">26.262 sec</td>
</tr>
<tr>
<td>runCluster (R-igraph)</td>
<td style="text-align: left">2.266 sec</td>
</tr>
<tr>
<td>runViz (Rtsne)</td>
<td style="text-align: left">41.009 sec</td>
</tr>
<tr>
<td>addGmatToSnap</td>
<td style="text-align: left">16.121 sec</td>
</tr>
<tr>
<td>addPmatToSnap</td>
<td style="text-align: left">22.689 sec</td>
</tr>
<tr>
<td>findDAR (Sst)</td>
<td style="text-align: left">18.811 sec</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td style="text-align: left"><strong>247.086 sec (&lt;5min)</strong></td>
</tr>
<tr>
<td><img width=450/></td>
<td style="text-align: left"><img width=300></td>
</tr>
</tbody>
</table>




</body>

</html>
